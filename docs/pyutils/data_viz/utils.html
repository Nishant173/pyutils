<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pyutils.data_viz.utils API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pyutils.data_viz.utils</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Any, Dict, List, Optional, Tuple, Union

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd

from pyutils.core.type_annotations import (
    Number,
    NumberOrString,
)
from pyutils.core.random_data_generator import generate_random_hex_codes
from pyutils.core.utils import (
    get_max_of_abs_values,
    has_negative_number,
    has_positive_number,
)
from pyutils.data_wrangler.transform import linspace_by_index


def __reorder_timseries_data(
        x_vals: List[NumberOrString],
        y_vals: List[Number],
    ) -&gt; pd.DataFrame:
    &#34;&#34;&#34;
    Re-orders values of x-axis and y-axis (for timeseries chart data) in ascending order of x-axis&#39; values.
    Returns DataFrame of re-ordered values. Columns returned are: `[&#39;x_vals&#39;, &#39;y_vals&#39;]`
    &#34;&#34;&#34;
    if len(x_vals) != len(y_vals):
        raise ValueError(
            &#34;Expected `x_vals` and `y_vals` to be of same length, but&#34;
            f&#34; got lengths {len(x_vals)} and {len(y_vals)} respectively&#34;
        )
    data = pd.DataFrame(data={
        &#39;x_vals&#39;: x_vals,
        &#39;y_vals&#39;: y_vals,
    })
    data.sort_values(by=&#39;x_vals&#39;, ascending=True, ignore_index=True, inplace=True)
    return data


def __plot_descriptive_stats(
        array: List[Number],
        orient: str,
        line_style: Optional[str] = &#34;-.&#34;,
        line_width: Optional[Number] = 2,
    ) -&gt; Any:
    &#34;&#34;&#34;
    Helper function to plot descriptive stats along one of the axes. Options for `orient`: [&#39;v&#39;, &#39;h&#39;].
    Returns matplotlib plot object that can be chained to more matplotlib code.
    &#34;&#34;&#34;
    mean = round(np.mean(array), 3)
    median = round(np.median(array), 3)
    if orient == &#39;v&#39;:
        obj = plt.axvline(x=mean, label=f&#34;Mean ({mean})&#34;, linestyle=line_style, linewidth=line_width, color=&#39;red&#39;)
        obj = plt.axvline(x=median, label=f&#34;Median ({median})&#34;, linestyle=line_style, linewidth=line_width, color=&#39;green&#39;)
    elif orient == &#39;h&#39;:
        obj = plt.axhline(y=mean, label=f&#34;Mean ({mean})&#34;, linestyle=line_style, linewidth=line_width, color=&#39;red&#39;)
        obj = plt.axhline(y=median, label=f&#34;Median ({median})&#34;, linestyle=line_style, linewidth=line_width, color=&#39;green&#39;)
    else:
        raise ValueError(f&#34;Expected `orient` to be in [&#39;v&#39;, &#39;h&#39;], but got &#39;{orient}&#39;&#34;)
    return obj


def get_calibrated_plot_fonts(fig_size: Tuple[int, int]) -&gt; Dict[str, float]:
    &#34;&#34;&#34;
    Takes in figure-size (tuple), and returns dictionary containing fontsizes for all other aspects
    of the plot (calculated and set appropriately, based on the figure-size).
    The fontsizes dictionary will have the following keys: `[&#39;title_size&#39;, &#39;label_size&#39;, &#39;tick_size&#39;, &#39;legend_label_size&#39;, &#39;annotation_size&#39;]`
    &#34;&#34;&#34;
    if isinstance(fig_size, tuple):
        if len(fig_size) == 2:
            width = int(fig_size[0])
        else:
            raise ValueError (f&#34;Invalid value for `fig_size`. Expected tuple of length 2, but got tuple of length {len(fig_size)}&#34;)
    else:
        raise TypeError(f&#34;Invalid type for `fig_size`. Expected &#39;tuple&#39; but got &#39;{type(fig_size)}&#39;&#34;)
    title_to_width_ratio = round((40 / 24), 3)
    labels_to_width_ratio = round((25 / 24), 3)
    ticks_to_width_ratio = round((20 / 24), 3)
    legend_labels_to_width_ratio = round((24 / 24), 3)
    annotation_to_width_ratio = round((18 / 24), 3)
    dictionary_calibrated_plot_fonts = {
        &#39;title_size&#39;: width * title_to_width_ratio,
        &#39;label_size&#39;: width * labels_to_width_ratio,
        &#39;tick_size&#39;: width * ticks_to_width_ratio,
        &#39;legend_label_size&#39;: width * legend_labels_to_width_ratio,
        &#39;annotation_size&#39;: width * annotation_to_width_ratio,
    }
    return dictionary_calibrated_plot_fonts


def add_plot_skeleton(
        title: str,
        x_label: str,
        y_label: str,
        fig_size: Tuple[int, int],
        include_labels: Optional[bool] = True,
        include_ticks: Optional[bool] = True,
    ) -&gt; Any:
    &#34;&#34;&#34;Returns matplotlib plot object, containing skeleton of basic aspects of a plot&#34;&#34;&#34;
    dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
    obj = plt.figure(figsize=fig_size)
    obj = plt.title(title, fontsize=dict_plot_fonts[&#39;title_size&#39;])
    if include_labels:
        obj = plt.xlabel(x_label, fontsize=dict_plot_fonts[&#39;label_size&#39;])
        obj = plt.ylabel(y_label, fontsize=dict_plot_fonts[&#39;label_size&#39;])
    if include_ticks:
        obj = plt.xticks(fontsize=dict_plot_fonts[&#39;tick_size&#39;])
        obj = plt.yticks(fontsize=dict_plot_fonts[&#39;tick_size&#39;])
    return obj


def plot_donut(
        title: str,
        labels: List[str],
        values: List[Number],
        colors: Optional[Union[List[str], List]] = [],
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    if not colors:
        colors = generate_random_hex_codes(how_many=len(labels))
    _, ax1 = plt.subplots()
    ax1.pie(x=list(values), labels=list(labels), colors=colors, autopct=&#39;%1.1f%%&#39;, startangle=40)
    centre_circle = plt.Circle((0,0), 0.70, fc=&#39;white&#39;)
    fig = plt.gcf()
    fig.gca().add_artist(centre_circle)
    ax1.axis(&#39;equal&#39;)  
    plt.tight_layout()
    plt.title(title, fontsize=15)
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None


def plot_bar(
        title: str,
        x_label: str,
        y_label: str,
        horizontal: bool,
        bar_labels: List[str],
        bar_values: List[Number],
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        colors: Optional[Union[List[str], List]] = [],
        annotate: Optional[bool] = True,
        symmetrical: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    add_plot_skeleton(title=title,
                      x_label=x_label,
                      y_label=y_label,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=True)
    if not colors:
        colors = generate_random_hex_codes(how_many=len(bar_labels))
    if horizontal:
        plt.barh(y=bar_labels, width=bar_values, color=colors)
    else:
        plt.bar(x=bar_labels, height=bar_values, color=colors)
    if annotate:
        dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
        annotation_size = dict_plot_fonts[&#39;annotation_size&#39;]
    if annotate and horizontal:
        for idx, value in enumerate(bar_values):
            plt.text(x = value * 1.01,
                     y = idx,
                     s = str(value),
                     fontweight=&#39;bold&#39;,
                     fontsize=annotation_size,
                     color=&#39;black&#39;)
    if annotate and not horizontal:
        for idx, value in enumerate(bar_values):
            plt.text(x = idx,
                     y = value * 1.01,
                     s = str(value),
                     fontweight=&#39;bold&#39;,
                     fontsize=annotation_size,
                     color=&#39;black&#39;)
    if symmetrical:
        if has_negative_number(array=bar_values) and has_positive_number(array=bar_values):
            axis_limit = get_max_of_abs_values(array=bar_values) * 1.05
            if horizontal:
                plt.xlim(-axis_limit, axis_limit)
            else:
                plt.ylim(-axis_limit, axis_limit)
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None


def plot_valuecounts(
        title: str,
        array: List[Any],
        array_description: str,
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        normalize: Optional[bool] = False,
        colors: Optional[Union[List[str], List]] = [],
        symmetrical: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    series = pd.Series(data=array)
    if normalize:
        dict_valuecounts = series.value_counts(normalize=True).mul(100).apply(round, args=[2]).to_dict()
        x_label = &#34;Percentage of occurences&#34;
    else:
        dict_valuecounts = series.value_counts().to_dict()
        x_label = &#34;Count of occurences&#34;
    plot_bar(title=title,
             x_label=x_label,
             y_label=array_description,
             horizontal=True,
             bar_labels=list(dict_valuecounts.keys()),
             bar_values=list(dict_valuecounts.values()),
             fig_size=fig_size,
             colors=colors,
             annotate=False,
             symmetrical=symmetrical,
             save_at=save_at,
             show=show)
    return None


def plot_timeseries(
        title: str,
        x_label: str,
        y_label: str,
        x_vals: List[Any],
        y_vals: List[Number],
        trim_xticks: Optional[bool] = True,
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        area_fill: Optional[bool] = False,
        area_color: Optional[str] = &#34;skyblue&#34;,
        area_alpha: Optional[float] = 0.4,
        line_width: Optional[Number] = 3,
        line_color: Optional[str] = &#34;#135FB6&#34;,
        show_scatter_points: Optional[bool] = False,
        scatter_points_size: Optional[int] = 250,
        describe: Optional[bool] = False,
        symmetrical: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    &#34;&#34;&#34;Note: Expects `x_vals` to denote time-related data, and `y_vals` to denote the timeseries curve/line itself&#34;&#34;&#34;
    add_plot_skeleton(title=title,
                      x_label=x_label,
                      y_label=y_label,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=False)
    x_vals, y_vals = list(x_vals), list(y_vals)
    df_timeseries_data = __reorder_timseries_data(x_vals=x_vals, y_vals=y_vals)
    if area_fill:
        plt.fill_between(df_timeseries_data[&#39;x_vals&#39;],
                         df_timeseries_data[&#39;y_vals&#39;],
                         color=area_color,
                         alpha=area_alpha)
    plt.plot(df_timeseries_data[&#39;x_vals&#39;],
             df_timeseries_data[&#39;y_vals&#39;],
             color=line_color,
             linewidth=line_width)
    xticks = df_timeseries_data[&#39;x_vals&#39;].tolist()
    if trim_xticks:
        xticks = linspace_by_index(array=xticks, how_many=5)
    dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
    tick_size = dict_plot_fonts[&#39;tick_size&#39;]
    plt.xticks(xticks, fontsize=tick_size)
    plt.yticks(fontsize=tick_size)
    if symmetrical:
        y_vals = df_timeseries_data[&#39;y_vals&#39;].tolist()
        if has_negative_number(array=y_vals) and has_positive_number(array=y_vals):
            axis_limit = get_max_of_abs_values(array=y_vals) * 1.05
            plt.ylim(-axis_limit, axis_limit)
    if show_scatter_points:
        plt.scatter(df_timeseries_data[&#39;x_vals&#39;],
                    df_timeseries_data[&#39;y_vals&#39;],
                    color=&#34;black&#34;,
                    s=scatter_points_size,
                    marker=&#39;*&#39;,
                    label=None)
    if describe:
        __plot_descriptive_stats(array=y_vals, orient=&#39;h&#39;, line_style=&#34;-.&#34;, line_width=line_width)
    if describe: # Showing legend
        dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
        legend_label_size = dict_plot_fonts[&#39;legend_label_size&#39;]
        plt.legend(loc=&#39;best&#39;, fontsize=legend_label_size)
    plt.grid()
    plt.tight_layout()
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None


def plot_scatter(
        title: str,
        x_label: str,
        y_label: str,
        x_vals: List[Number],
        y_vals: List[Number],
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        color: Optional[str] = &#39;g&#39;,
        alpha: Optional[float] = None,
        size: Optional[int] = 80,
        grid: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    add_plot_skeleton(title=title,
                      x_label=x_label,
                      y_label=y_label,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=True)
    plt.scatter(x=list(x_vals), y=list(y_vals), c=color, s=size, alpha=alpha)
    if grid:
        plt.grid()
    plt.tight_layout()
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None


def plot_histogram(
        title: str,
        array: List[Number],
        array_description: str,
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        bins: Optional[int] = 10,
        color: Optional[str] = &#34;#2B88CA&#34;,
        describe: Optional[bool] = False,
        line_width: Optional[Number] = 3,
        grid: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    add_plot_skeleton(title=title,
                      x_label=array_description,
                      y_label=&#34;Frequency&#34;,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=True)
    plt.hist(x=array, bins=bins, color=color)
    if describe:
        __plot_descriptive_stats(array=array, orient=&#39;v&#39;, line_style=&#34;-.&#34;, line_width=line_width)
    if describe: # Showing legend
        dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
        legend_label_size = dict_plot_fonts[&#39;legend_label_size&#39;]
        plt.legend(loc=&#39;best&#39;, fontsize=legend_label_size)
    if grid:
        plt.grid()
    plt.tight_layout()
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None


def plot_radar(
        title: str,
        labels: List[str],
        values: List[Number],
        ticks: Optional[List[Number]] = None,
        tick_limit: Optional[Tuple[Number, Number]] = None,
        fig_size: Optional[Tuple[int, int]] = (15, 9),
        color: Optional[str] = None,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    dict_calibrated_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
    angles = np.linspace(start=0, stop=2*np.pi, num=len(labels), endpoint=False)
    values = np.concatenate((values, [values[0]]))
    labels = np.concatenate((labels, [labels[0]]))
    angles = np.concatenate((angles, [angles[0]]))
    
    fig = plt.figure(figsize=fig_size)
    ax = fig.add_subplot(111, polar=True)
    ax.plot(angles, values, &#39;o-&#39;, linewidth=2.5, c=color)
    ax.fill(angles, values, alpha=0.35, c=color)
    ax.set_thetagrids(angles * 180 / np.pi, labels, size=dict_calibrated_plot_fonts[&#39;label_size&#39;])
    ax.grid(True)
    if ticks:
        plt.yticks(ticks, size=dict_calibrated_plot_fonts[&#39;tick_size&#39;])
    else:
        plt.yticks([])
    if tick_limit:
        plt.ylim(tick_limit)
    plt.title(title, size=dict_calibrated_plot_fonts[&#39;title_size&#39;])
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pyutils.data_viz.utils.add_plot_skeleton"><code class="name flex">
<span>def <span class="ident">add_plot_skeleton</span></span>(<span>title: str, x_label: str, y_label: str, fig_size: Tuple[int, int], include_labels: Optional[bool] = True, include_ticks: Optional[bool] = True) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Returns matplotlib plot object, containing skeleton of basic aspects of a plot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_plot_skeleton(
        title: str,
        x_label: str,
        y_label: str,
        fig_size: Tuple[int, int],
        include_labels: Optional[bool] = True,
        include_ticks: Optional[bool] = True,
    ) -&gt; Any:
    &#34;&#34;&#34;Returns matplotlib plot object, containing skeleton of basic aspects of a plot&#34;&#34;&#34;
    dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
    obj = plt.figure(figsize=fig_size)
    obj = plt.title(title, fontsize=dict_plot_fonts[&#39;title_size&#39;])
    if include_labels:
        obj = plt.xlabel(x_label, fontsize=dict_plot_fonts[&#39;label_size&#39;])
        obj = plt.ylabel(y_label, fontsize=dict_plot_fonts[&#39;label_size&#39;])
    if include_ticks:
        obj = plt.xticks(fontsize=dict_plot_fonts[&#39;tick_size&#39;])
        obj = plt.yticks(fontsize=dict_plot_fonts[&#39;tick_size&#39;])
    return obj</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.get_calibrated_plot_fonts"><code class="name flex">
<span>def <span class="ident">get_calibrated_plot_fonts</span></span>(<span>fig_size: Tuple[int, int]) ‑> Dict[str, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in figure-size (tuple), and returns dictionary containing fontsizes for all other aspects
of the plot (calculated and set appropriately, based on the figure-size).
The fontsizes dictionary will have the following keys: <code>['title_size', 'label_size', 'tick_size', 'legend_label_size', 'annotation_size']</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_calibrated_plot_fonts(fig_size: Tuple[int, int]) -&gt; Dict[str, float]:
    &#34;&#34;&#34;
    Takes in figure-size (tuple), and returns dictionary containing fontsizes for all other aspects
    of the plot (calculated and set appropriately, based on the figure-size).
    The fontsizes dictionary will have the following keys: `[&#39;title_size&#39;, &#39;label_size&#39;, &#39;tick_size&#39;, &#39;legend_label_size&#39;, &#39;annotation_size&#39;]`
    &#34;&#34;&#34;
    if isinstance(fig_size, tuple):
        if len(fig_size) == 2:
            width = int(fig_size[0])
        else:
            raise ValueError (f&#34;Invalid value for `fig_size`. Expected tuple of length 2, but got tuple of length {len(fig_size)}&#34;)
    else:
        raise TypeError(f&#34;Invalid type for `fig_size`. Expected &#39;tuple&#39; but got &#39;{type(fig_size)}&#39;&#34;)
    title_to_width_ratio = round((40 / 24), 3)
    labels_to_width_ratio = round((25 / 24), 3)
    ticks_to_width_ratio = round((20 / 24), 3)
    legend_labels_to_width_ratio = round((24 / 24), 3)
    annotation_to_width_ratio = round((18 / 24), 3)
    dictionary_calibrated_plot_fonts = {
        &#39;title_size&#39;: width * title_to_width_ratio,
        &#39;label_size&#39;: width * labels_to_width_ratio,
        &#39;tick_size&#39;: width * ticks_to_width_ratio,
        &#39;legend_label_size&#39;: width * legend_labels_to_width_ratio,
        &#39;annotation_size&#39;: width * annotation_to_width_ratio,
    }
    return dictionary_calibrated_plot_fonts</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_bar"><code class="name flex">
<span>def <span class="ident">plot_bar</span></span>(<span>title: str, x_label: str, y_label: str, horizontal: bool, bar_labels: List[str], bar_values: List[Union[int, float]], fig_size: Optional[Tuple[int, int]] = (12, 5), colors: Optional[List] = [], annotate: Optional[bool] = True, symmetrical: Optional[bool] = True, save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_bar(
        title: str,
        x_label: str,
        y_label: str,
        horizontal: bool,
        bar_labels: List[str],
        bar_values: List[Number],
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        colors: Optional[Union[List[str], List]] = [],
        annotate: Optional[bool] = True,
        symmetrical: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    add_plot_skeleton(title=title,
                      x_label=x_label,
                      y_label=y_label,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=True)
    if not colors:
        colors = generate_random_hex_codes(how_many=len(bar_labels))
    if horizontal:
        plt.barh(y=bar_labels, width=bar_values, color=colors)
    else:
        plt.bar(x=bar_labels, height=bar_values, color=colors)
    if annotate:
        dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
        annotation_size = dict_plot_fonts[&#39;annotation_size&#39;]
    if annotate and horizontal:
        for idx, value in enumerate(bar_values):
            plt.text(x = value * 1.01,
                     y = idx,
                     s = str(value),
                     fontweight=&#39;bold&#39;,
                     fontsize=annotation_size,
                     color=&#39;black&#39;)
    if annotate and not horizontal:
        for idx, value in enumerate(bar_values):
            plt.text(x = idx,
                     y = value * 1.01,
                     s = str(value),
                     fontweight=&#39;bold&#39;,
                     fontsize=annotation_size,
                     color=&#39;black&#39;)
    if symmetrical:
        if has_negative_number(array=bar_values) and has_positive_number(array=bar_values):
            axis_limit = get_max_of_abs_values(array=bar_values) * 1.05
            if horizontal:
                plt.xlim(-axis_limit, axis_limit)
            else:
                plt.ylim(-axis_limit, axis_limit)
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_donut"><code class="name flex">
<span>def <span class="ident">plot_donut</span></span>(<span>title: str, labels: List[str], values: List[Union[int, float]], colors: Optional[List] = [], save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_donut(
        title: str,
        labels: List[str],
        values: List[Number],
        colors: Optional[Union[List[str], List]] = [],
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    if not colors:
        colors = generate_random_hex_codes(how_many=len(labels))
    _, ax1 = plt.subplots()
    ax1.pie(x=list(values), labels=list(labels), colors=colors, autopct=&#39;%1.1f%%&#39;, startangle=40)
    centre_circle = plt.Circle((0,0), 0.70, fc=&#39;white&#39;)
    fig = plt.gcf()
    fig.gca().add_artist(centre_circle)
    ax1.axis(&#39;equal&#39;)  
    plt.tight_layout()
    plt.title(title, fontsize=15)
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_histogram"><code class="name flex">
<span>def <span class="ident">plot_histogram</span></span>(<span>title: str, array: List[Union[int, float]], array_description: str, fig_size: Optional[Tuple[int, int]] = (12, 5), bins: Optional[int] = 10, color: Optional[str] = '#2B88CA', describe: Optional[bool] = False, line_width: Union[float, int, NoneType] = 3, grid: Optional[bool] = True, save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_histogram(
        title: str,
        array: List[Number],
        array_description: str,
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        bins: Optional[int] = 10,
        color: Optional[str] = &#34;#2B88CA&#34;,
        describe: Optional[bool] = False,
        line_width: Optional[Number] = 3,
        grid: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    add_plot_skeleton(title=title,
                      x_label=array_description,
                      y_label=&#34;Frequency&#34;,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=True)
    plt.hist(x=array, bins=bins, color=color)
    if describe:
        __plot_descriptive_stats(array=array, orient=&#39;v&#39;, line_style=&#34;-.&#34;, line_width=line_width)
    if describe: # Showing legend
        dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
        legend_label_size = dict_plot_fonts[&#39;legend_label_size&#39;]
        plt.legend(loc=&#39;best&#39;, fontsize=legend_label_size)
    if grid:
        plt.grid()
    plt.tight_layout()
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_radar"><code class="name flex">
<span>def <span class="ident">plot_radar</span></span>(<span>title: str, labels: List[str], values: List[Union[int, float]], ticks: Optional[List[Union[int, float]]] = None, tick_limit: Optional[Tuple[Union[int, float], Union[int, float]]] = None, fig_size: Optional[Tuple[int, int]] = (15, 9), color: Optional[str] = None, save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_radar(
        title: str,
        labels: List[str],
        values: List[Number],
        ticks: Optional[List[Number]] = None,
        tick_limit: Optional[Tuple[Number, Number]] = None,
        fig_size: Optional[Tuple[int, int]] = (15, 9),
        color: Optional[str] = None,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    dict_calibrated_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
    angles = np.linspace(start=0, stop=2*np.pi, num=len(labels), endpoint=False)
    values = np.concatenate((values, [values[0]]))
    labels = np.concatenate((labels, [labels[0]]))
    angles = np.concatenate((angles, [angles[0]]))
    
    fig = plt.figure(figsize=fig_size)
    ax = fig.add_subplot(111, polar=True)
    ax.plot(angles, values, &#39;o-&#39;, linewidth=2.5, c=color)
    ax.fill(angles, values, alpha=0.35, c=color)
    ax.set_thetagrids(angles * 180 / np.pi, labels, size=dict_calibrated_plot_fonts[&#39;label_size&#39;])
    ax.grid(True)
    if ticks:
        plt.yticks(ticks, size=dict_calibrated_plot_fonts[&#39;tick_size&#39;])
    else:
        plt.yticks([])
    if tick_limit:
        plt.ylim(tick_limit)
    plt.title(title, size=dict_calibrated_plot_fonts[&#39;title_size&#39;])
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_scatter"><code class="name flex">
<span>def <span class="ident">plot_scatter</span></span>(<span>title: str, x_label: str, y_label: str, x_vals: List[Union[int, float]], y_vals: List[Union[int, float]], fig_size: Optional[Tuple[int, int]] = (12, 5), color: Optional[str] = 'g', alpha: Optional[float] = None, size: Optional[int] = 80, grid: Optional[bool] = True, save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_scatter(
        title: str,
        x_label: str,
        y_label: str,
        x_vals: List[Number],
        y_vals: List[Number],
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        color: Optional[str] = &#39;g&#39;,
        alpha: Optional[float] = None,
        size: Optional[int] = 80,
        grid: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    add_plot_skeleton(title=title,
                      x_label=x_label,
                      y_label=y_label,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=True)
    plt.scatter(x=list(x_vals), y=list(y_vals), c=color, s=size, alpha=alpha)
    if grid:
        plt.grid()
    plt.tight_layout()
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_timeseries"><code class="name flex">
<span>def <span class="ident">plot_timeseries</span></span>(<span>title: str, x_label: str, y_label: str, x_vals: List[Any], y_vals: List[Union[int, float]], trim_xticks: Optional[bool] = True, fig_size: Optional[Tuple[int, int]] = (12, 5), area_fill: Optional[bool] = False, area_color: Optional[str] = 'skyblue', area_alpha: Optional[float] = 0.4, line_width: Union[float, int, NoneType] = 3, line_color: Optional[str] = '#135FB6', show_scatter_points: Optional[bool] = False, scatter_points_size: Optional[int] = 250, describe: Optional[bool] = False, symmetrical: Optional[bool] = True, save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Note: Expects <code>x_vals</code> to denote time-related data, and <code>y_vals</code> to denote the timeseries curve/line itself</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_timeseries(
        title: str,
        x_label: str,
        y_label: str,
        x_vals: List[Any],
        y_vals: List[Number],
        trim_xticks: Optional[bool] = True,
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        area_fill: Optional[bool] = False,
        area_color: Optional[str] = &#34;skyblue&#34;,
        area_alpha: Optional[float] = 0.4,
        line_width: Optional[Number] = 3,
        line_color: Optional[str] = &#34;#135FB6&#34;,
        show_scatter_points: Optional[bool] = False,
        scatter_points_size: Optional[int] = 250,
        describe: Optional[bool] = False,
        symmetrical: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    &#34;&#34;&#34;Note: Expects `x_vals` to denote time-related data, and `y_vals` to denote the timeseries curve/line itself&#34;&#34;&#34;
    add_plot_skeleton(title=title,
                      x_label=x_label,
                      y_label=y_label,
                      fig_size=fig_size,
                      include_labels=True,
                      include_ticks=False)
    x_vals, y_vals = list(x_vals), list(y_vals)
    df_timeseries_data = __reorder_timseries_data(x_vals=x_vals, y_vals=y_vals)
    if area_fill:
        plt.fill_between(df_timeseries_data[&#39;x_vals&#39;],
                         df_timeseries_data[&#39;y_vals&#39;],
                         color=area_color,
                         alpha=area_alpha)
    plt.plot(df_timeseries_data[&#39;x_vals&#39;],
             df_timeseries_data[&#39;y_vals&#39;],
             color=line_color,
             linewidth=line_width)
    xticks = df_timeseries_data[&#39;x_vals&#39;].tolist()
    if trim_xticks:
        xticks = linspace_by_index(array=xticks, how_many=5)
    dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
    tick_size = dict_plot_fonts[&#39;tick_size&#39;]
    plt.xticks(xticks, fontsize=tick_size)
    plt.yticks(fontsize=tick_size)
    if symmetrical:
        y_vals = df_timeseries_data[&#39;y_vals&#39;].tolist()
        if has_negative_number(array=y_vals) and has_positive_number(array=y_vals):
            axis_limit = get_max_of_abs_values(array=y_vals) * 1.05
            plt.ylim(-axis_limit, axis_limit)
    if show_scatter_points:
        plt.scatter(df_timeseries_data[&#39;x_vals&#39;],
                    df_timeseries_data[&#39;y_vals&#39;],
                    color=&#34;black&#34;,
                    s=scatter_points_size,
                    marker=&#39;*&#39;,
                    label=None)
    if describe:
        __plot_descriptive_stats(array=y_vals, orient=&#39;h&#39;, line_style=&#34;-.&#34;, line_width=line_width)
    if describe: # Showing legend
        dict_plot_fonts = get_calibrated_plot_fonts(fig_size=fig_size)
        legend_label_size = dict_plot_fonts[&#39;legend_label_size&#39;]
        plt.legend(loc=&#39;best&#39;, fontsize=legend_label_size)
    plt.grid()
    plt.tight_layout()
    if save_at:
        plt.savefig(save_at)
    if show:
        plt.show()
    plt.close()
    return None</code></pre>
</details>
</dd>
<dt id="pyutils.data_viz.utils.plot_valuecounts"><code class="name flex">
<span>def <span class="ident">plot_valuecounts</span></span>(<span>title: str, array: List[Any], array_description: str, fig_size: Optional[Tuple[int, int]] = (12, 5), normalize: Optional[bool] = False, colors: Optional[List] = [], symmetrical: Optional[bool] = True, save_at: Optional[str] = None, show: Optional[bool] = False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_valuecounts(
        title: str,
        array: List[Any],
        array_description: str,
        fig_size: Optional[Tuple[int, int]] = (12, 5),
        normalize: Optional[bool] = False,
        colors: Optional[Union[List[str], List]] = [],
        symmetrical: Optional[bool] = True,
        save_at: Optional[str] = None,
        show: Optional[bool] = False,
    ) -&gt; None:
    series = pd.Series(data=array)
    if normalize:
        dict_valuecounts = series.value_counts(normalize=True).mul(100).apply(round, args=[2]).to_dict()
        x_label = &#34;Percentage of occurences&#34;
    else:
        dict_valuecounts = series.value_counts().to_dict()
        x_label = &#34;Count of occurences&#34;
    plot_bar(title=title,
             x_label=x_label,
             y_label=array_description,
             horizontal=True,
             bar_labels=list(dict_valuecounts.keys()),
             bar_values=list(dict_valuecounts.values()),
             fig_size=fig_size,
             colors=colors,
             annotate=False,
             symmetrical=symmetrical,
             save_at=save_at,
             show=show)
    return None</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pyutils.data_viz" href="index.html">pyutils.data_viz</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pyutils.data_viz.utils.add_plot_skeleton" href="#pyutils.data_viz.utils.add_plot_skeleton">add_plot_skeleton</a></code></li>
<li><code><a title="pyutils.data_viz.utils.get_calibrated_plot_fonts" href="#pyutils.data_viz.utils.get_calibrated_plot_fonts">get_calibrated_plot_fonts</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_bar" href="#pyutils.data_viz.utils.plot_bar">plot_bar</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_donut" href="#pyutils.data_viz.utils.plot_donut">plot_donut</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_histogram" href="#pyutils.data_viz.utils.plot_histogram">plot_histogram</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_radar" href="#pyutils.data_viz.utils.plot_radar">plot_radar</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_scatter" href="#pyutils.data_viz.utils.plot_scatter">plot_scatter</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_timeseries" href="#pyutils.data_viz.utils.plot_timeseries">plot_timeseries</a></code></li>
<li><code><a title="pyutils.data_viz.utils.plot_valuecounts" href="#pyutils.data_viz.utils.plot_valuecounts">plot_valuecounts</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>